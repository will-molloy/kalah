<h1>CK Metrics</h1>
<p></p>
<table style="empty-cells: show" border>
  <tr valign=top>
    <th style="text-align:left">Timestamp</th>
    <td>Sat May 05 10:59:08 NZST 2018</td>
  </tr>
  <tr valign=top>
    <th style="text-align:left">Tool</th>
    <td>mete-analysis(ck metrics):20180206T1230</td>
  </tr>
  <tr valign=top>
    <th style="text-align:left">System</th>
    <td>design1020</td>
  </tr>
  <tr valign=top>
    <th style="text-align:left">Codebase</th>
    <td>/opt/code_corpora/grad005-01/grad005-01/design1020/design1020</td>
  </tr>
</table>
<h3>Measurements</h3>
<h4>Metadata<h4>
<table style="empty-cells: show" border>
  <tr valign=top>
    <td colspan="6">WMC (Size)</td>
    <td>UnboundedCount</td>
    <td>(srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (srccons) Consider constructors as invokers as creating coupling; (init) Record all dependencies including those in all initialisers; (raw) Do not record dependencies due to synthetic constructs; (srcmem) Include dependencies to members of all visibilities in source</td>
  </tr>
  <tr valign=top>
    <td colspan="6">LCOM (Cohesion)</td>
    <td>UnboundedCount</td>
    <td>(srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (srcmeth) Do not consider constructors as invokers as creating coupling; (init) Record all dependencies including those in all initialisers; (srcmem) Include dependencies to members of all visibilities in source</td>
  </tr>
  <tr valign=top>
    <td colspan="6">CBO (Coupling)</td>
    <td>UnboundedCount</td>
    <td>(trgtdcl) Only record dependencies to target modules whose declarations have been seen; (srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (trgtsttic) Record dependencies to both instance and static fields and methods in the target module; (srccons) Consider constructors as invokers as creating coupling; (trgtcons) Record both invoking methods and calling construtors as creating dependencies; (type) Record dependencies between all types, including interfaces, enums, an annotations; (anc) Include dependencies to ancestors of source; (desc) Include descendants to ancestors of source; (inh) Include dependencies on targets whose accessed members were inherited; (poly) Include dependencies on targets whose members were accessed via polymorphism; (bidir) Dependencies are recorded as bi-directional. If A has a dependency to B, then B has a dependency to A; (fanout) Record only dependencies from source to target (no-op when bidir); (mod) Record dependencies between modules (as opposed to between packages); (pres) Record only the presence (or not) of an occurrence of a dependency between entities; (nest) Consider nested or enclosing types are separate; (raw) Do not record dependencies due to synthetic constructs</td>
  </tr>
  <tr valign=top>
    <td colspan="6">RFC (Coupling)</td>
    <td>UnboundedCount</td>
    <td>(trgtall) Record dependencies to target modules whether or not the declarations have been seen; (srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (trgtsttic) Record dependencies to both instance and static fields and methods in the target module; (trgtcons) Record both invoking methods and calling construtors as creating dependencies; (type) Record dependencies between all types, including interfaces, enums, an annotations</td>
  </tr>
  <tr valign=top>
    <td colspan="6">NOC (Inheritance)</td>
    <td>UnboundedCount</td>
    <td>(srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (srccons) Consider constructors as invokers as creating coupling; (init) Record all dependencies including those in all initialisers; (raw) Do not record dependencies due to synthetic constructs; (srcmem) Include dependencies to members of all visibilities in source</td>
  </tr>
  <tr valign=top>
    <td colspan="6">DIT (Inheritance)</td>
    <td>UnboundedCount</td>
    <td>(srcsttc) Record dependencies with respect to both instance and static fields and methods in the source module; (srccons) Consider constructors as invokers as creating coupling; (init) Record all dependencies including those in all initialisers; (raw) Do not record dependencies due to synthetic constructs; (srcmem) Include dependencies to members of all visibilities in source</td>
  </tr>
</table>
<h4>Data<h4>
<table style="empty-cells: show" border>
  <tr valign=top>
    <th>Entity</th>
    <th>WMC (Size)</th>
    <th>LCOM (Cohesion)</th>
    <th>CBO (Coupling)</th>
    <th>RFC (Coupling)</th>
    <th>NOC (Inheritance)</th>
    <th>DIT (Inheritance)</th>
  </tr>
  <tr valign=top>
    <td>kalah.Kalah</td>
    <td>4</td>
    <td>0</td>
    <td>2</td>
    <td>19</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr valign=top>
    <td>myPackage.Board</td>
    <td>11</td>
    <td>0</td>
    <td>8</td>
    <td>37</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr valign=top>
    <td>myPackage.House</td>
    <td>7</td>
    <td>9</td>
    <td>5</td>
    <td>14</td>
    <td>0</td>
    <td>2</td>
  </tr>
  <tr valign=top>
    <td>myPackage.IPrinter</td>
    <td>3</td>
    <td>0</td>
    <td>1</td>
    <td>3</td>
    <td>1</td>
    <td>0</td>
  </tr>
  <tr valign=top>
    <td>myPackage.IRule</td>
    <td>1</td>
    <td>0</td>
    <td>2</td>
    <td>1</td>
    <td>3</td>
    <td>0</td>
  </tr>
  <tr valign=top>
    <td>myPackage.Pit</td>
    <td>6</td>
    <td>0</td>
    <td>6</td>
    <td>15</td>
    <td>2</td>
    <td>1</td>
  </tr>
  <tr valign=top>
    <td>myPackage.Player</td>
    <td>18</td>
    <td>52</td>
    <td>11</td>
    <td>85</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr valign=top>
    <td>myPackage.Printer</td>
    <td>11</td>
    <td>0</td>
    <td>7</td>
    <td>54</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr valign=top>
    <td>myPackage.RuleCapture</td>
    <td>2</td>
    <td>0</td>
    <td>4</td>
    <td>11</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr valign=top>
    <td>myPackage.RuleHouseIsEmpty</td>
    <td>2</td>
    <td>0</td>
    <td>4</td>
    <td>7</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr valign=top>
    <td>myPackage.RuleWillEndAtEmptyHouse</td>
    <td>2</td>
    <td>0</td>
    <td>4</td>
    <td>6</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr valign=top>
    <td>myPackage.Seed</td>
    <td>1</td>
    <td>0</td>
    <td>4</td>
    <td>2</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr valign=top>
    <td>myPackage.SeedOverFlowAndHouseNumber</td>
    <td>7</td>
    <td>0</td>
    <td>3</td>
    <td>6</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr valign=top>
    <td>myPackage.Store</td>
    <td>3</td>
    <td>0</td>
    <td>5</td>
    <td>6</td>
    <td>0</td>
    <td>2</td>
  </tr>
  <tr valign=top>
    <td>myPackage.Variables</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>2</td>
    <td>0</td>
    <td>1</td>
  </tr>
</table>
